<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ohanator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #0f0;
        }
        
        #gameContainer {
            text-align: center;
        }
        
        canvas {
            border: 2px solid #0f0;
            background: #000;
            display: block;
            margin: 0 auto;
            border-radius: 50%;
        }
        
        #ui {
            margin-top: 20px;
            font-size: 18px;
        }
        
        #gameOver {
            display: none;
            margin-top: 20px;
            font-size: 24px;
            color: #f00;
        }
        
        #instructions {
            margin-top: 15px;
            font-size: 14px;
            color: #0f0;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="600" height="600"></canvas>
        <div id="ui">
            <span>SCORE: <span id="score">0</span></span> | 
            <span>OHANS: <span id="lives">3</span></span> | 
            <span>BROS: <span id="kills">0</span></span>
        </div>
        <div id="gameOver">
            GAME OVER<br>
            <span style="font-size: 16px;">Press SPACE to restart</span>
        </div>
        <div id="instructions">
            ← → ARROW KEYS to move around circle | SPACE to shoot
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = {
            score: 0,
            lives: 3,
            kills: 0,
            running: true,
            gameOver: false
        };
        
        // Player
        const player = {
            angle: -Math.PI / 2, // Start at top (12 o'clock)
            radius: 270, // Distance from center (near edge)
            width: 70,
            height: 70,
            speed: 0.03, // Angular speed
            moving: { clockwise: false, counterclockwise: false }
        };
        
        // Bullets
        let bullets = [];
        const bulletSpeed = 7;
        const bulletCooldown = 250;
        let lastBulletTime = 0;
        
        // Enemies
        let enemies = [];
        let lastEnemySpawn = 0;
        const enemySpawnInterval = 1500; // Spawn every 1.5 seconds
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // Enemy bullets
        let enemyBullets = [];
        const enemyShootChance = 0.001;
        
        // Particles for explosions
        let particles = [];
        
        // Spawn a single enemy from random angle
        function spawnEnemy() {
            // Pick a random angle for entry point
            const entryAngle = Math.random() * Math.PI * 2;
            const spawnRadius = 300; // Start at circle edge
            const entryX = centerX + Math.cos(entryAngle) * spawnRadius;
            const entryY = centerY + Math.sin(entryAngle) * spawnRadius;
            
            // Strong bias toward paths that go through central areas
            // Smaller angle differences = paths closer to center
            const angleOffset = (Math.random() * 0.4 + 0.4) * Math.PI; // Mostly 0.4π to 0.8π (very central)
            const exitAngle = entryAngle + angleOffset;
            const exitX = centerX + Math.cos(exitAngle) * spawnRadius;
            const exitY = centerY + Math.sin(exitAngle) * spawnRadius;
            
            // Calculate direction (secant line from entry to exit)
            const dirX = exitX - entryX;
            const dirY = exitY - entryY;
            const magnitude = Math.sqrt(dirX * dirX + dirY * dirY);
            
            const speed = 2;
            
            // Generate random face features
            const hairColors = ['#333', '#8b4513', '#ffd700', '#ff6347', '#000'];
            const skinTones = ['#ffdbac', '#f1c27d', '#e0ac69', '#c68642', '#8d5524'];
            const hasGlasses = Math.random() > 0.5;
            const hasBeard = Math.random() > 0.6;
            const hasMustache = Math.random() > 0.5;
            const isBald = Math.random() > 0.4;
            
            enemies.push({
                x: entryX,
                y: entryY,
                vx: (dirX / magnitude) * speed,
                vy: (dirY / magnitude) * speed,
                width: 70,
                height: 70,
                alive: true,
                type: Math.random() < 0.3 ? 'fast' : 'normal',
                // Face attributes
                hairColor: hairColors[Math.floor(Math.random() * hairColors.length)],
                skinTone: skinTones[Math.floor(Math.random() * skinTones.length)],
                hasGlasses: hasGlasses,
                hasBeard: hasBeard,
                hasMustache: hasMustache,
                isBald: isBald,
                eyeColor: Math.random() > 0.5 ? '#0066cc' : '#4a2511'
            });
        }
        
        // Draw player
        function drawPlayer() {
            const px = player.x;
            const py = player.y;
            const scale = 2; // 2x size for more detail
            
            // Hair outline - balding pattern with minimal top hair (darker red)
            ctx.fillStyle = '#aa2200';
            // Very thin top hair - just a bit
            ctx.fillRect(px + 20, py + 8, 30, 3);
            // Side hair
            ctx.fillRect(px + 10, py + 18, 8, 12);
            ctx.fillRect(px + 52, py + 18, 8, 12);
            
            // Face base (skin tone)
            ctx.fillStyle = '#ffcc99';
            ctx.fillRect(px + 12, py + 10, 46, 48);
            
            // Bald head shine
            ctx.fillStyle = '#ffddb3';
            ctx.fillRect(px + 24, py + 6, 22, 6);
            ctx.fillRect(px + 28, py + 4, 14, 2);
            
            // Top hair detail (red/ginger) - very minimal
            ctx.fillStyle = '#cc3300';
            ctx.fillRect(px + 20, py + 11, 30, 4);
            
            // Side hair detail (red/ginger)
            ctx.fillStyle = '#cc3300';
            ctx.fillRect(px + 10, py + 18, 8, 16);
            ctx.fillRect(px + 52, py + 18, 8, 16);
            ctx.fillRect(px + 12, py + 14, 6, 8);
            ctx.fillRect(px + 52, py + 14, 6, 8);
            
            // Ear shadows
            ctx.fillStyle = '#ffaa77';
            ctx.fillRect(px + 8, py + 28, 4, 14);
            ctx.fillRect(px + 58, py + 28, 4, 14);
            
            // Eyebrows (dark red)
            ctx.fillStyle = '#882200';
            ctx.fillRect(px + 18, py + 26, 10, 3);
            ctx.fillRect(px + 42, py + 26, 10, 3);
            
            // Glasses frames (black)
            ctx.fillStyle = '#222';
            // Left lens
            ctx.fillRect(px + 18, py + 30, 12, 10);
            // Right lens
            ctx.fillRect(px + 40, py + 30, 12, 10);
            // Bridge
            ctx.fillRect(px + 30, py + 33, 10, 3);
            // Left arm
            ctx.fillRect(px + 16, py + 33, 2, 2);
            ctx.fillRect(px + 12, py + 32, 4, 3);
            // Right arm
            ctx.fillRect(px + 52, py + 33, 2, 2);
            ctx.fillRect(px + 54, py + 32, 4, 3);
            
            // Glasses lenses (lighter for transparency effect)
            ctx.fillStyle = '#88ccee';
            ctx.fillRect(px + 19, py + 31, 10, 8);
            ctx.fillRect(px + 41, py + 31, 10, 8);
            
            // Eyes behind glasses (white)
            ctx.fillStyle = '#fff';
            ctx.fillRect(px + 20, py + 32, 8, 6);
            ctx.fillRect(px + 42, py + 32, 8, 6);
            
            // Pupils
            ctx.fillStyle = '#0066cc';
            ctx.fillRect(px + 22, py + 34, 4, 4);
            ctx.fillRect(px + 44, py + 34, 4, 4);
            
            // Pupil shine
            ctx.fillStyle = '#fff';
            ctx.fillRect(px + 24, py + 35, 2, 2);
            ctx.fillRect(px + 46, py + 35, 2, 2);
            
            // Nose
            ctx.fillStyle = '#ffaa77';
            ctx.fillRect(px + 33, py + 40, 4, 8);
            ctx.fillRect(px + 31, py + 46, 3, 3);
            ctx.fillRect(px + 36, py + 46, 3, 3);
            
            // Mustache (red/ginger) - connects to beard
            ctx.fillStyle = '#cc3300';
            ctx.fillRect(px + 22, py + 48, 26, 5);
            ctx.fillRect(px + 20, py + 49, 30, 4);
            ctx.fillRect(px + 18, py + 51, 34, 3);
            
            // Mustache highlights
            ctx.fillStyle = '#ee5533';
            ctx.fillRect(px + 24, py + 49, 6, 2);
            ctx.fillRect(px + 40, py + 49, 6, 2);
            
            // Mouth under mustache
            ctx.fillStyle = '#994422';
            ctx.fillRect(px + 30, py + 50, 10, 2);
            
            // Beard (red/ginger) - connects to mustache
            ctx.fillStyle = '#cc3300';
            // Chin beard - connects from mustache
            ctx.fillRect(px + 24, py + 54, 22, 6);
            ctx.fillRect(px + 22, py + 56, 26, 6);
            ctx.fillRect(px + 26, py + 60, 18, 4);
            ctx.fillRect(px + 28, py + 64, 14, 3);
            
            // Side beard/sideburns - connects to side hair and mustache
            ctx.fillRect(px + 12, py + 44, 8, 14);
            ctx.fillRect(px + 50, py + 44, 8, 14);
            ctx.fillRect(px + 16, py + 54, 8, 8);
            ctx.fillRect(px + 46, py + 54, 8, 8);
            
            // Beard highlights (lighter red)
            ctx.fillStyle = '#ee5533';
            ctx.fillRect(px + 26, py + 56, 6, 3);
            ctx.fillRect(px + 38, py + 56, 6, 3);
            ctx.fillRect(px + 30, py + 60, 4, 2);
        }
        
        // Draw enemy
        function drawEnemy(enemy) {
            if (!enemy.alive) return;
            
            const ex = enemy.x;
            const ey = enemy.y;
            
            // Hair (if not bald)
            if (!enemy.isBald) {
                ctx.fillStyle = enemy.hairColor;
                ctx.fillRect(ex + 18, ex + 6, 34, 4);
                ctx.fillRect(ex + 20, ey + 10, 30, 3);
                ctx.fillRect(ex + 14, ey + 8, 42, 6);
                ctx.fillRect(ex + 10, ey + 14, 6, 8);
                ctx.fillRect(ex + 54, ey + 14, 6, 8);
            } else {
                // Bald head shine
                ctx.fillStyle = enemy.skinTone;
                ctx.fillRect(ex + 24, ey + 6, 22, 6);
                ctx.fillRect(ex + 28, ey + 4, 14, 2);
                // Side hair only
                ctx.fillStyle = enemy.hairColor;
                ctx.fillRect(ex + 10, ey + 18, 8, 12);
                ctx.fillRect(ex + 52, ey + 18, 8, 12);
            }
            
            // Face base (skin tone)
            ctx.fillStyle = enemy.skinTone;
            ctx.fillRect(ex + 12, ey + 10, 46, 48);
            
            // Ears
            const earShade = shadeColor(enemy.skinTone, -20);
            ctx.fillStyle = earShade;
            ctx.fillRect(ex + 8, ey + 28, 4, 14);
            ctx.fillRect(ex + 58, ey + 28, 4, 14);
            
            // Eyebrows
            ctx.fillStyle = enemy.hairColor;
            ctx.fillRect(ex + 18, ey + 26, 10, 3);
            ctx.fillRect(ex + 42, ey + 26, 10, 3);
            
            if (enemy.hasGlasses) {
                // Glasses frames
                ctx.fillStyle = '#222';
                ctx.fillRect(ex + 18, ey + 30, 12, 10);
                ctx.fillRect(ex + 40, ey + 30, 12, 10);
                ctx.fillRect(ex + 30, ey + 33, 10, 3);
                ctx.fillRect(ex + 16, ey + 33, 2, 2);
                ctx.fillRect(ex + 52, ey + 33, 2, 2);
                
                // Lenses
                ctx.fillStyle = '#88ccee';
                ctx.fillRect(ex + 19, ey + 31, 10, 8);
                ctx.fillRect(ex + 41, ey + 31, 10, 8);
            }
            
            // Eyes
            ctx.fillStyle = '#fff';
            ctx.fillRect(ex + 20, ey + 32, 8, 6);
            ctx.fillRect(ex + 42, ey + 32, 8, 6);
            
            // Pupils
            ctx.fillStyle = enemy.eyeColor;
            ctx.fillRect(ex + 22, ey + 34, 4, 4);
            ctx.fillRect(ex + 44, ey + 34, 4, 4);
            
            // Pupil shine
            ctx.fillStyle = '#fff';
            ctx.fillRect(ex + 24, ey + 35, 2, 2);
            ctx.fillRect(ex + 46, ey + 35, 2, 2);
            
            // Nose
            const noseShade = shadeColor(enemy.skinTone, -15);
            ctx.fillStyle = noseShade;
            ctx.fillRect(ex + 33, ey + 40, 4, 8);
            ctx.fillRect(ex + 31, ey + 46, 3, 3);
            ctx.fillRect(ex + 36, ey + 46, 3, 3);
            
            if (enemy.hasMustache) {
                // Mustache
                ctx.fillStyle = enemy.hairColor;
                ctx.fillRect(ex + 22, ey + 48, 26, 5);
                ctx.fillRect(ex + 20, ey + 49, 30, 4);
                ctx.fillRect(ex + 18, ey + 51, 34, 3);
            }
            
            // Mouth
            ctx.fillStyle = '#994422';
            ctx.fillRect(ex + 30, ey + 50, 10, 2);
            
            if (enemy.hasBeard) {
                // Beard
                ctx.fillStyle = enemy.hairColor;
                ctx.fillRect(ex + 24, ey + 54, 22, 6);
                ctx.fillRect(ex + 22, ey + 56, 26, 6);
                ctx.fillRect(ex + 26, ey + 60, 18, 4);
                ctx.fillRect(ex + 28, ey + 64, 14, 3);
                
                // Side beard
                ctx.fillRect(ex + 12, ey + 44, 8, 14);
                ctx.fillRect(ex + 50, ey + 44, 8, 14);
            }
        }
        
        // Helper function to shade colors
        function shadeColor(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
                (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
                .toString(16).slice(1);
        }
        
        // Draw bullet
        function drawBullet(bullet) {
            if (bullet.friendly) {
                // Player bullets are red letter O's
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 20px Arial';
                ctx.fillText('O', bullet.x - 6, bullet.y + 6);
            } else {
                // Enemy bullets stay as rectangles
                ctx.fillStyle = '#f00';
                ctx.fillRect(bullet.x, bullet.y, 3, 10);
            }
        }
        
        // Create explosion particles
        function createExplosion(x, y, color) {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 30,
                    color: color
                });
            }
        }
        
        // Update and draw particles
        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.fillRect(p.x, p.y, 2, 2);
                ctx.globalAlpha = 1;
                
                return p.life > 0;
            });
        }
        
        // Update player
        function updatePlayer() {
            if (player.moving.counterclockwise) {
                player.angle -= player.speed;
            }
            if (player.moving.clockwise) {
                player.angle += player.speed;
            }
            
            // Calculate player position from angle
            player.x = centerX + Math.cos(player.angle) * player.radius - player.width / 2;
            player.y = centerY + Math.sin(player.angle) * player.radius - player.height / 2;
        }
        
        // Update bullets
        function updateBullets() {
            // Player bullets move in straight line toward center and beyond
            bullets = bullets.filter(bullet => {
                // If bullet doesn't have a direction yet, calculate it
                if (!bullet.vx) {
                    const dx = centerX - bullet.x;
                    const dy = centerY - bullet.y;
                    const magnitude = Math.sqrt(dx * dx + dy * dy);
                    bullet.vx = (dx / magnitude) * bulletSpeed;
                    bullet.vy = (dy / magnitude) * bulletSpeed;
                }
                
                // Move in the set direction
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                
                // Remove only when they exit the circle completely
                const distToCenter = Math.sqrt((bullet.x - centerX) ** 2 + (bullet.y - centerY) ** 2);
                return distToCenter < 350;
            });
            
            // Enemy bullets move in their direction
            enemyBullets = enemyBullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                
                // Remove if off screen
                const distToCenter = Math.sqrt((bullet.x - centerX) ** 2 + (bullet.y - centerY) ** 2);
                return distToCenter < 350;
            });
        }
        
        // Update enemies
        function updateEnemies() {
            const now = Date.now();
            
            // Spawn new enemies periodically
            if (now - lastEnemySpawn > enemySpawnInterval) {
                spawnEnemy();
                lastEnemySpawn = now;
            }
            
            // Move enemies along their secant path
            for (let enemy of enemies) {
                if (!enemy.alive) continue;
                
                enemy.x += enemy.vx;
                enemy.y += enemy.vy;
                
                // Random shooting
                if (Math.random() < enemyShootChance) {
                    enemyBullets.push({
                        x: enemy.x + enemy.width / 2,
                        y: enemy.y + enemy.height / 2,
                        vx: enemy.vx * 1.5,
                        vy: enemy.vy * 1.5,
                        friendly: false
                    });
                }
            }
            
            // Remove enemies that have completely exited the circle
            enemies = enemies.filter(e => {
                if (!e.alive) return false;
                const dx = e.x - centerX;
                const dy = e.y - centerY;
                const distFromCenter = Math.sqrt(dx * dx + dy * dy);
                // Keep enemies while they're within or near the circle (give buffer for complete exit)
                return distFromCenter < 400;
            });
        }
        
        // Check collisions
        function checkCollisions() {
            // Player bullets vs enemies
            for (let bullet of bullets) {
                for (let enemy of enemies) {
                    if (enemy.alive &&
                        bullet.x >= enemy.x &&
                        bullet.x <= enemy.x + enemy.width &&
                        bullet.y >= enemy.y &&
                        bullet.y <= enemy.y + enemy.height) {
                        enemy.alive = false;
                        // Remove bullet by setting it far away
                        bullet.x = -1000;
                        bullet.y = -1000;
                        gameState.score += enemy.type === 'fast' ? 20 : 10;
                        gameState.kills++;
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#0ff');
                        document.getElementById('score').textContent = gameState.score;
                        document.getElementById('kills').textContent = gameState.kills;
                    }
                }
            }
            
            // Enemy bullets vs player
            for (let bullet of enemyBullets) {
                if (bullet.x >= player.x &&
                    bullet.x <= player.x + player.width &&
                    bullet.y >= player.y &&
                    bullet.y <= player.y + player.height) {
                    bullet.x = -1000;
                    bullet.y = -1000;
                    gameState.lives--;
                    createExplosion(player.x + player.width/2, player.y + player.height/2, '#0f0');
                    document.getElementById('lives').textContent = gameState.lives;
                    
                    if (gameState.lives <= 0) {
                        endGame();
                    }
                }
            }
            
            // Enemies vs player (direct collision)
            for (let enemy of enemies) {
                if (enemy.alive &&
                    enemy.x < player.x + player.width &&
                    enemy.x + enemy.width > player.x &&
                    enemy.y < player.y + player.height &&
                    enemy.y + enemy.height > player.y) {
                    enemy.alive = false;
                    gameState.lives--;
                    createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#f00');
                    createExplosion(player.x + player.width/2, player.y + player.height/2, '#0f0');
                    document.getElementById('lives').textContent = gameState.lives;
                    
                    if (gameState.lives <= 0) {
                        endGame();
                    }
                }
            }
        }
        
        // End game
        function endGame() {
            gameState.running = false;
            gameState.gameOver = true;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        // Restart game
        function restartGame() {
            gameState = {
                score: 0,
                lives: 3,
                kills: 0,
                running: true,
                gameOver: false
            };
            player.angle = -Math.PI / 2;
            bullets = [];
            enemyBullets = [];
            enemies = [];
            particles = [];
            lastEnemySpawn = 0;
            document.getElementById('score').textContent = 0;
            document.getElementById('lives').textContent = 3;
            document.getElementById('kills').textContent = 0;
            document.getElementById('gameOver').style.display = 'none';
        }
        
        // Game loop
        function gameLoop() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Create circular clipping path
            ctx.save();
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, canvas.width / 2, 0, Math.PI * 2);
            ctx.clip();
            
            if (gameState.running) {
                updatePlayer();
                updateBullets();
                updateEnemies();
                checkCollisions();
            }
            
            // Draw everything
            drawPlayer();
            bullets.forEach(drawBullet);
            enemyBullets.forEach(drawBullet);
            enemies.forEach(drawEnemy);
            updateParticles();
            
            ctx.restore();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                player.moving.counterclockwise = true;
            }
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                player.moving.clockwise = true;
            }
            
            if (e.key === ' ') {
                e.preventDefault();
                
                if (gameState.gameOver) {
                    restartGame();
                } else if (gameState.running) {
                    const now = Date.now();
                    if (now - lastBulletTime > bulletCooldown) {
                        bullets.push({
                            x: player.x + player.width / 2,
                            y: player.y + player.height / 2,
                            friendly: true
                        });
                        lastBulletTime = now;
                    }
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') {
                player.moving.counterclockwise = false;
            }
            if (e.key === 'ArrowRight') {
                player.moving.clockwise = false;
            }
        });
        
        // Start game
        gameLoop();
    </script>
</body>
</html>
